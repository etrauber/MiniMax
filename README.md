# Minimax project
## Background and Motivation
Nim is a two-player mathematical game, in which players alternate taking a certain amount of pieces off of a pile. For each turn, a player is able to take one, two, or three pieces off the pile, assuming there are three or more pieces on the pile. The goal of the game is to make the pile so that there is only one piece left, and subsequently the other player will have to take the last piece. The player who takes the last piece in the pile loses. 
Within our NimRunner code, we implemented a very important function, and evidently algorithm, called minimax. Minimax is essentially an algorithm that rates each move a player could possibly take as either 1 or -1, in order to determine if they player should make that given move. In order to implement the minimax function, we used an algorithm that would take in a move and the person's turn it is, and return if that move would be beneficial. In order to do this, we first created a base case that would use an if statement to determine if there are zero pieces left. If this is the case, the function would return 1 if it is playerX's turn and -1 if it is not, highlighting that if playerX took the last piece, represented by a -1, they lost but if it returns 1, playerX has won. However, recursion plays a large role in the rest of this algorithm. This is because in order to determine if a move is a good choice, we need to look through each of the possible successive moves, therefore requiring minimax to call itself. In the original function, a loop is needed to be called 3 times (so long as total pieces in greater than 3), in order to test the score of taking 3, 2, and 1 pieces. Then, within this loop, the function is recalled, while changing the number of pieces in the parameter to the total original pieces - number of pieces taken (indicated by the for loop), as well as changing the player. The function will eventually create a list of the possible scores assosiatced with the pieces taken, and depending on who's turn it is, it will return the minimum or maximum of these scores, indicating whether or not the player should make this move. 
Nim is a good test case of the algorithm of minimax because it represents a simplified two player game that requires a thoughtful process to determine how many pieces off the pile should be taken. This algorithm is able to spit out a 1 or -1, indicating if this move is smart, and evidently if the player should make it. As a result, it allows playerX to determine the best possible moves and beat their opponent almost every time. Subsequently, Nim is a great test case for minimax as it is also a game that allows us to manually determine if a move is smart or not, easily checking the credibility of our minimax function (thought in a slower manner than the method itself). 
## Usage
